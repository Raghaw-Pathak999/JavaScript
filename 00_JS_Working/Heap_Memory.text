=========================================================================================
=========================================================================================

2. Heap (Dynamic Memory)

---------------------------------------------------------------------------------------

** What is the Heap? **

Heap memory is a region inside the V8 engine = A big memory area where dynamic data is stored. Dynamic means data that can grow, shrink, or live for an unknown time.

** What gets stored in Heap? **

-- Objects: { name: "Alice", age: 25 }
-- Arrays: [1,2,3,4]
-- Functions function(){} (because closures need persistent environments)
-- Closures’ captured variables
-- Strings (non-primitive, large ones)
-- Buffers (Node.js memory for binary data)
-- Any data too big for stack

** In JS (V8):- **

V8 (the engine behind Chrome & Node.js) divides memory into two main parts:

--Stack → for short-term function calls, local variables, references.
--Heap → for long-term, flexible data like objects, arrays, functions.

** Why Heap is needed:- **

In JS, objects and arrays can change size at runtime. Their lifetime is not fixed (they may live until something points to them). That’s why they can’t live on the stack. They go to the heap.

** Spec vs Engine: **

The JavaScript spec doesn’t say “put objects in heap,” but engines (like V8) do it this way in practice.

-- Objects, arrays, functions → stored in Heap.
-- Primitives (number, boolean, null, undefined, symbol, bigint, string contents) → may be stored differently, but if inside an object/array, they still end up in heap indirectly.

** Lifetime management: **

In JS, you don’t “free” memory manually. The Garbage Collector (GC) in V8 automatically cleans heap memory when an object is no longer reachable (no reference pointing to it).

---------------------------------------------------------------------------------------

** Stack vs Heap **

1. What is Stack?

-Stack is a small and very fast memory area.
-It is used for function calls.
-Every function call creates a stack frame → inside it, arguments, local variables, and -references are stored.
-When the function ends, its stack frame is removed automatically.
-So, data in stack has a short life (only while function is running).

2. What is Heap?

-Heap is a large and flexible memory area.
-It stores data that can live beyond a single function call.
-Example: Objects, Arrays, Functions, Closures.
-The lifetime of data in heap depends on whether something is still referencing it.

** Difference (Stack vs Heap):- **

Stack:

-- Very fast, small, temporary.
-- Primitive values (numbers, booleans) can be stored directly.
-- Memory is freed automatically when function ends.

Heap:

-- Bigger, slower (because it’s flexible).
-- Objects, Arrays, Functions are stored here.
-- Garbage Collector decides when to free memory.

---------------------------------------------------------------------------------------

** What goes inside the Heap in JS **


** Objects **
Every {} you create is stored in the heap.
-- Example: let obj = {name: "Ali", age: 25};
-- obj (the reference) is in stack.
-- The actual object {name: "Ali", age: 25} is in heap.
-- Variable (reference) stored in stack, actual object stored in heap.
-- Objects always live in the heap.

** Arrays **
-- Arrays are also objects → so they live in the heap.
-- Example: let arr = [1, 2, 3];
-- Reference arr in stack, The array data [1,2,3] in heap.
-- Heap allows resizing (push, pop), heap adjusts (because heap is flexible).


** Functions **
-- Functions in JS are also objects.
-- So their code object and closure environment are stored in heap.
-- Example:- function greet() { return "hello"; }
-- Reference to greet in stack.
-- Function object (with its properties) in heap.
-- Function object + its properties live in the heap.

** Closures **
-- Closures keep variables alive inside heap even after outer function ends.
-- Captured variables are stored in heap.
-- Example:
   function outer() {
     let a = 10;
     return function inner() {
       return a;
     }
   }
   let fn = outer();  // "a" lives in heap because inner() needs it.
-- Normally, a would die when outer ends.
-- But because inner still needs a, V8 keeps a in heap (inside closure environment).
-- This is why closures are powerful but can also cause memory leaks if misused.


** Strings **
-- Small/primitive strings may be optimized differently.
-- Large or complex strings are stored in heap. V8 may put them in heap.
-- Example: let str = "This is a big string..."; heap will be used.

** Special Objects **
-- Dates, RegExps, Maps, Sets, WeakMaps, WeakSets → all stored in heap.
-- Buffers (Node.js binary data) are also in heap.
-- Anything created with new keyword (new Error(), new Promise()) → heap.


** Quick Summary **
-- Heap contains: Objects, Arrays, Functions, Closures, Large Strings, Special Objects.
-- Stack only keeps references (pointers) to these heap objects.

---------------------------------------------------------------------------------------

** How memory is allocated in Heap (V8 internals) **


1. What happens when you write let obj = {x:10}

--- V8 sees the code and decides to create a new object {x:10}

--- Heap memory is requested:-
-- V8 asks the operating system for a block of memory (or uses pre-allocated heap space)

--- Stack stores a reference:-
-- The variable obj itself lives in stack
-- It points to the object in heap

--- Visualization:-

  Stack   Heap
  -----   ----------------------------
  obj  -> { x: 10, internal metadata }

-- Stack: small, fast, temporary
-- Heap: large, dynamic, holds actual object



2. Why V8 divides Heap into spaces:-

Heap is huge, but allocating/finding memory can be slow
V8 splits heap into smaller spaces to manage efficiently:-
-New Space → short-lived objects
-Old Space → long-lived objects
-Large Object Space → huge objects
-Code Space → JIT compiled function code

Purpose:-
-- Fast allocation/deallocation
-- Reduce fragmentation
-- Optimize GC

Main goal of allocation:-
-- Give fast memory allocation for objects
-- Keep low overhead → don’t waste CPU or memory
-- Ensure objects can be efficiently managed and collected by GC

** 3. Bump-Pointer Allocation in V8 ** 

*1. What is Bump-Pointer Allocation?

-- Bump-pointer is a fast memory allocation strategy used in V8’s New Space

Idea:-
1. Keep a pointer that points to the next free memory location in the heap
2. To allocate a new object:-
    -Take the current pointer → assign memory for the object
    -Move (“bump”) the pointer forward by the size of the object

-- No searching for free blocks
-- No linked list or metadata traversal
-- Extremely fast → just pointer arithmetic

*2. How it works step by step

Example:-
let a = { x: 10 };
let b = { y: 20 };

Step by Step:-

-- 1. Heap setup: V8 has a bump pointer at the start of New Space

Heap Start ---> [free memory] <--- Bump Pointer here

-- 2. Allocate a:-
    - Pointer points to free memory → assign space for { x: 10 }
    - Move pointer forward by object size

Heap: [ { x:10 } ] [free memory]
Pointer now points here ---> ready for next allocation

-- 3. Allocate b:-
    - Pointer points to next free memory → assign { y: 20 }
    - Move pointer forward again

Heap: [ { x:10 }, { y:20 } ] [free memory]
Pointer now points here

No searching, no fragmentation, very fast allocation

*3. Advantages of Bump-Pointer

1. Speed: Just arithmetic → O(1) allocation
2. Simplicity: No complex memory management for short-lived objects
3. Efficient in New Space: Most objects are short-lived → minor GC clears them, pointer resets

*4. Visualization

Heap New Space: [free][free][free][free] ...
Bump Pointer ---> points to first free block

Allocate Object A:
Heap: [A][free][free][free] ...
Pointer ---> next free

Allocate Object B:
Heap: [A][B][free][free] ...
Pointer ---> next free

- Very fast because no searching is involved
- Works perfectly for short-lived objects

*5. What happens when New Space is full?

If the bump pointer reaches the end of New Space:-

-- Trigger Minor GC → remove dead objects
-- Reset bump pointer to start of free space
-- Promote surviving objects to Old Space if needed
-- Continue allocations

Key Takeaways:-

- Bump-Pointer = fast allocation in New Space
- Just keeps a pointer, assigns memory, bumps forward
- Ideal for most JS objects, which are short-lived
- When full → minor GC → pointer resets

*** Real understanding Example Of heap Memory Allocation:- ***

let suppose:- 

V8 requests a block of memory from OS for heap to store objects ( Let Memory is 0 to 100 )

we suppose * is Pointer

Memory:-
0 1 2 3 4 5 6 7 8 9 10 11 12 13 .............. 100
* ( Pointer is allocate on the 0 index when no object in heap )

Now We have 3 objects:- 
Obj 1 size - 10
Obj 2 size - 7
Obj 3 size - 4

Memory:- (when obj 1)
0 1 2 3 4 5 6 7 8 9 10 11 12 13 .............. 100
1 1 1 1 1 1 1 1 1 1 * (pointer move forward obj 1 is store 0 to 9)

Memory:- (when obj 2)
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ....... 100
1 1 1 1 1 1 1 1 1 1 2  2  2  2  2  2  2  * (pointer move forward obj 2 is store 10 to 16)

Memory:- (when obj 2)
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ....... 100
1 1 1 1 1 1 1 1 1 1 2  2  2  2  2  2  2  3  3  3  3  * (same for third obj)

-- This all are store in new space all newly Objects are store in new Space because may this are short live objects

-- Garbage Collector is Clear for dead object (means that are not used)

-- when Garbage collected clear but some obj are useable so they object are Promoted to old space here long live objects are stored

-- Age Promoted means when objects are not clear by Garbage Collector so age is increase that how objects are Promoted to new space to old spaces

-- When objects are remove(cleans) by Garbage collecter so fragmentation(gaps happens) in memory so We dynamic memory allocate basis three Way:-

-First fit:- first space where obj fit Easliy
-Best fit:- best space space also where obj fit Easliy
-Worst fit:- Worst means too much space area where objects Easliy fit

---------------------------------------------------------------------------------------

** Minor GC (Young Generation Collection) **

== step 1 ==>> Why Minor GC is needed? <<===

1. New Space / Nursery

-- New-space is a small, fast memory region in the Heap.
-- Objects are allocated linearly using bump-pointer.

Visualization:-
New Space: [free][free][free] ... (small)
Bump Pointer (*) ---> next free block

-As JS code runs, many temporary objects are created:
-Intermediate arrays
-Temporary closures
-Short-lived function results

** 2. Problem without Minor GC **

- Bump-pointer keeps moving forward with each allocation
- Eventually → New Space fills up
- No more memory available for new objects → allocation fails
- We need a mechanism to free memory efficiently

Key point:-
-Most objects in JS die quickly → we don’t need to scan the entire heap.

Summary Step 1:-

- New Space is small → bump-pointer fills it quickly
- JS creates many short-lived objects → most die soon
- Minor GC is needed → to remove dead objects and free New Space only
- Goal: fast, efficient cleanup without scanning Old Space

** Minor GC targets New Space only
** New Space = small, short-lived objects → easy to clean
** Without Minor GC → memory allocation fails when New Space fills
** Most objects die young → Minor GC can be very fast

== step 2 ==>> Key Observation – Object Lifetime <<===

1. Observation by V8 Developers

While analyzing JS apps, V8 developers noticed:- Most objects are short-lived

Examples of short-lived objects:-

- Temporary arrays or intermediate results in calculations
- Function-scoped variables that are not returned
- Closures used briefly and discarded
- Small temporary objects in loops

2. Why This Matters

-- If most objects die quickly:-

- Scanning all heap memory would be wasteful
- Minor GC can only scan New Space → fast

-- Surviving objects (long-lived) are rare → promoted to Old Space

3. Mental Model

-- New Space = “nursery”
-- Objects born here:
    - Short-lived → die in next GC → memory cleared
    - Long-lived → survive multiple Minor GCs → promoted    

Key Takeaways Step 2:-

1. Most JS objects die young → short-lived
2. Minor GC can focus on New Space only → efficient
3. Surviving objects are rare → will be promoted later
4. This observation is the foundation of Scavenge algorithm

== step 3 ==>> Copying / Scavenge Algorithm <<===

1. Why Copying?

- New Space = small, linear memory
- Objects are short-lived → most die quickly
- Copying only surviving objects to another space is fast and memory-efficient

2. Semi-Space Organization

New Space is divided into two halves:-
[From-Space] [To-Space]

1. From-Space → currently used for allocations
2. To-Space → empty, will hold survivors after GC
- Together they form the semi-space system

3. Allocation Phase:-

- Objects are allocated in From-Space using bump pointer

- From-Space: [obj1][obj2][obj3] ---> pointer at next free
- To-Space: empty

4. Minor GC Trigger

-- When From-Space is full → Minor GC starts
-- Step-by-step:-
1. V8 identifies roots → stack references, global objects
2. GC scans From-Space for reachable objects

5. Scavenge Step

-- Reachable objects are copied to To-Space, compacted side by side

Example:-
From-Space: [obj1][obj2][obj3]
Reachable: obj1, obj3
To-Space: [obj1][obj3] ---> compact, no gaps

-- Unreachable objects → ignored, memory automatically cleared

6. Flip

After copying:-

From-Space → old garbage
To-Space → survivors

-- Flip roles: next allocation happens in new To-Space
-- Previous From-Space becomes empty → ready for next GC

7. Promotion to Old Space

-- Objects surviving multiple Minor GCs → considered long-lived
-- Promoted to Old Space to avoid repeated copying

Example:- 
Short-lived: tempArray, tempObj → cleared after 1 GC
Long-lived: configObject → promoted to Old Space

8. Mental Picture / Analogy

New Space = drawer with two compartments:-
-- From = current side where you put stuff
-- To = empty side

When drawer is full:-
-- Cleaner comes → removes useless stuff
-- Moves useful stuff neatly to empty side
-- Flip sides → now new allocations happen in empty side

Key Takeaways Step 3:-

1. Minor GC uses Copying / Scavenge algorithm
2. From-Space = allocate new objects
3. To-Space = collect survivors, compact memory
4. Flip roles after GC → next allocations in To-Space
5. Short-lived objects die, long-lived objects promoted

== step 4 ==>> Benefits of Minor GC <<===

1. Fast and Efficient

-- Minor GC scans only New Space (small memory), not the entire heap.
-- Most objects die young → less work for GC → fast cleanup

2. Automatic Memory Compaction

-- During copying, surviving objects are moved side by side in To-Space
-- No gaps / fragmentation
-- Makes memory allocation for new objects faster

3. Optimized for Short-Lived Objects

-- JS programs often create temporary objects → loops, intermediate calculations
-- Minor GC is designed to clean these quickly without touching long-lived objects in Old Space

4. Reduced Overhead

-- Because only a small portion of heap is scanned, CPU overhead is minimal
-- Keeps JS execution smooth and non-blocking

5. Mental Picture / Analogy

New Space = Small drawer for temporary papers
- Most papers = thrown away quickly → fast cleaning
- Important papers = moved to cabinet (Old Space)
- Drawer is compact, no gaps → easy to put next papers

Key Takeaways Step 5:-

1. Minor GC works fast because New Space is small
2. Surviving objects are compacted → efficient memory usage
3. Short-lived objects die quickly → reduces GC cost
4. Long-lived objects get promoted → no repeated copying

== Minor GC Step 6: Mental Picture / Example ==>

1. Setup

* New Space = small memory area for temporary objects
* Divided into **From-Space** and **To-Space**
* Suppose objects allocated sequentially:

From-Space (current): [obj1][obj2][obj3][obj4]  ← allocation pointer at end
To-Space (empty): []

2. Trigger GC

* From-Space is full → Minor GC triggers
* GC scans **roots** (stack references, globals) to find **reachable objects**
* Example:

Reachable: obj1, obj3
Unreachable: obj2, obj4

3. Copying Survivors to To-Space

* Only reachable objects are copied:

To-Space after copying: [obj1][obj3] ← compacted, side by side
No gaps / fragmentation

* Unreachable objects (obj2, obj4) → automatically cleared

4. Flip Spaces

* Roles are swapped:

From-Space → empty (ready for new allocation)
To-Space → now active allocation space

* Next allocations go into new From-Space (old To-Space)

5. Promotion to Old Space

* If obj1 survives **multiple Minor GCs**, it is considered long-lived → promoted:

Old Space: [obj1]  ← stays for long term

* Reduces copying in future Minor GCs

-------------------------------------------------------------------------------------

** Major GC (Old Generation Collection) **

================= Step 1. Why Major GC is needed ===========>>>

1. Minor GC limitation

-- Minor GC works only on New Space (nursery)
-- Short-lived objects die quickly → Minor GC is efficient
-- Problem: long-lived objects (global configs, caches, large app data) survive many Minor GCs

2. Promotion to Old Space

-- Surviving objects are promoted to Old Space
-- Old Space = bigger memory area, stores long-lived objects

3. Old Space Challenges

-- Old Space fills up over time → memory pressure increases
-- Fragmentation occurs → free memory is scattered in small gaps
-- If not cleaned → allocation slows down, performance drops

4. Need for Major GC

-- Major GC cleans Old Space → ensures long-lived objects don’t block memory
-- Handles objects Minor GC can’t efficiently manage
-- Keeps application smooth and responsive

5. Mental Picture

Old Space = Big godown for long-term storage
- Minor GC handles small room (nursery) → short-lived stuff
- Long-lived items accumulate → godown gets messy
- Major GC = janitor comes:
   1. Mark useful items
   2. Sweep useless items
   3. Compact to organize space

Key Takeaways Step 1:-

1. Minor GC only cleans New Space → cannot manage long-lived objects
2. Old Space fills up with promoted objects → needs cleaning
2. Major GC ensures long-term memory management, avoids app slowdowns

======= Major GC Step 2: Approach (Mark → Sweep → Compact) =======>>>>

1. Major GC Overview

-- Major GC handles Old Space (long-lived objects).
-- It is **slower and heavier** than Minor GC.
-- Uses three main steps: **Mark → Sweep → Compact**.

2. Step 1: Mark

-- Starts from **GC roots**: global variables, active stack frames, closures.
-- Traverses objects using DFS/BFS.
-- Marks reachable objects as **alive**.
-- Unmarked objects = unreachable = garbage.

3. Step 2: Sweep

-- Scans entire heap.
-- Frees memory of **unmarked objects**.
-- Marks freed memory as available.
-- Can cause **fragmentation** (gaps in memory).

4. Step 3: Compact (optional but common)

-- To remove fragmentation, GC **moves surviving objects together**.
-- Free space becomes contiguous.
-- Costly step, but improves **long-term allocation performance**.

5. Mental Picture

Old Space = Big godown
- Mark: check which items are still useful
- Sweep: remove broken or unnecessary items
- Compact: arrange useful items neatly, fill gaps

6. Key Takeaways Step 2

1. Major GC cleans Old Space → slow but necessary.
2. Steps: Mark → Sweep → (sometimes Compact).
3. Compacting improves memory allocation and reduces fragmentation.

=========== Major GC Step 3: Incremental & Concurrent GC =========>>>>

1. Why Incremental & Concurrent GC?

-- Major GC is slow → if done in one shot, JS app can **freeze** (stop-the-world).
-- To avoid long pauses, V8 splits GC work into smaller chunks.

2. Incremental Marking

-- Marking phase is divided into **small steps**.
-- JS execution continues **between steps**.
-- Reduces pause time and keeps app responsive.

3. Concurrent Sweeping

-- Sweeping of unmarked objects happens in **background threads**.
-- App execution is mostly unaffected.
-- Only minimal stopping is needed to sync memory.

4. Compacting GC

-- Sometimes fragmentation is high → V8 performs compacting.
-- Usually **stop-the-world**, rare occurrence.
-- Moves surviving objects together → free space becomes contiguous.

5. Mental Picture / Analogy

Old Space = Big godown
- Incremental Marking: check useful items in small batches while janitor works in parallel
- Concurrent Sweeping: janitor cleans up garbage items in background
- Compacting: rearrange items neatly (rare, heavy task)

6. Key Takeaways Step 3

1. Incremental + Concurrent GC avoids long pauses.
2. Marking is done in small steps → JS keeps running.
3. Sweeping can happen in background → reduces stop-the-world time.
4. Compacting is costly but helps long-term performance.

=========== Major GC Step 4: Example Mental Picture ========>>>>>

1. Mental Picture / Analogy

Old Space = Big godown for long-lived objects

* **Incremental Marking**: Janitor checks useful items in small batches while shop keeps running
* **Concurrent Sweeping**: Janitor removes garbage items in background threads
* **Compacting**: Rarely, janitor rearranges surviving items neatly to reduce fragmentation

2. Step-by-Step Visualization

* Imagine Old Space as a warehouse with boxes (objects)
* Some boxes are still used (marked), others are trash (unmarked)
* Incremental Marking: janitor tags useful boxes in small steps
* Concurrent Sweeping: janitor clears trash boxes in background
* Compacting: janitor moves remaining boxes together to make space contiguous

3. Key Takeaways

1. Helps avoid long pauses in JS execution
2. Marking done incrementally → app continues running
3. Sweeping mostly concurrent → minimal app interruption
4. Compacting occasional → fixes fragmentation

========== Major GC Step 5: Summary / Key Takeaways ==============>>>>>

1. Major GC cleans Old Space (long-lived objects)

-- Minor GC cannot efficiently clean long-lived objects → objects promoted to Old Space
-- Major GC handles this bigger memory area

2. Steps of Major GC

* **Mark**: Identify reachable objects from roots
* **Sweep**: Free memory of unmarked objects
* **Compact** (optional): Rearrange surviving objects to reduce fragmentation

3. Performance Optimizations

* **Incremental Marking**: Marking in small steps while JS continues
* **Concurrent Sweeping**: Cleaning garbage in background threads
* **Compacting**: Rare, expensive but organizes memory efficiently

4. Key Takeaways

1. Major GC ensures long-lived objects don’t block memory
2. Avoids app freeze by using incremental/concurrent techniques
3. Keeps JS application smooth and responsive
4. Needed when Old Space fills up or fragmentation occurs

-----------------------------------------------------------------------------------------

** V8 Heap Organization (Spaces in V8) **

1. New Space: Temporary apartments (short stay, fast cleaning)
2. Old Spaces: Permanent houses (long stay, slower cleaning)
3. Code Space: IT park (only code allowed)
4. Map Space: Registry office (object blueprints)
5. Large Object Space: Warehouses (giant stuff)
6. Read-Only: Museum (cannot change)
7. Shared Space: Public park (shared access)

=============== 1. New Space (Young Generation) ========>>

### 1. What is New Space?

* Small memory area inside V8 heap dedicated to short-lived objects.
* Often called **nursery**.
* Uses **bump-pointer allocation** for fast memory assignment.

### 2. Objects Allocated Here

* Temporary arrays, objects, closures created in function scope.
* Example:

function tempData() {
  let arr = [1,2,3]; // stored in New Space
  return arr;
}

* Each new object is placed linearly in New Space.

### 3. Garbage Collection

* Cleaned frequently via **Minor GC (Scavenge)**.
* Uses **From-space / To-space** semi-space strategy:

  * From-space = currently active allocation area
  * To-space = empty space for survivors
* Surviving objects copied from From-space → To-space.
* Dead objects automatically discarded.

### 4. Promotion to Old Space

* If an object survives multiple Minor GCs, it is considered long-lived.
* Such objects are **promoted to Old Space** for long-term storage.
* Reduces repeated copying in New Space.

### 5. Key Properties

* Fast allocation & deallocation.
* Efficient for short-lived objects.
* Compacting during Minor GC prevents fragmentation.
* Limited size → heavy objects or persistent data move to Old Space.

============ 2. Old Pointer Space =============>>>>

### 1. What is Old Pointer Space?
- Part of V8 Old Generation (long-lived objects).
- Stores objects that contain **pointers/references to other objects**.
- Managed by **Major GC** using **Mark-Sweep-Compact** algorithms.

### 2. Objects Allocated Here
- Objects that survive multiple Minor GCs.
- Example:

let globalConfig = {
  db: {host: 'localhost', port: 3306},
  cache: {userCount: 1000}
}; // Old Pointer Space

-Linked structures, closures, large objects with references.

###3. Garbage Collection

Slow, heavy compared to Minor GC.

Steps:-
Mark: Find reachable objects from roots.
Sweep: Free memory for unmarked (garbage) objects.
Compact (optional): Rearrange surviving objects to reduce fragmentation.

Key Properties:-
1. Optimized for long-lived objects.
2. Contains references → GC must trace pointers to avoid freeing live objects.
3. Allocation slower than New Space but more stable.
4. Less frequent GC cycles than New Space.

============== 3. Old Data Space ===============>>>>>

### 1. What is Old Data Space?

* Part of V8 Old Generation.
* Stores **long-lived objects that do not have many pointers**.
* Optimized differently from Old Pointer Space for memory efficiency.

### 2. Objects Allocated Here

* Large arrays of primitive values.
* Large strings or buffers without complex references.

* Example:-
let largeArray = new Array(10000).fill(0); // Old Data Space
let bigString = 'a'.repeat(100000); // Old Data Space

### 3. Garbage Collection

* Managed by **Major GC** (Mark-Sweep-Compact).
* Marking checks reachability.
* Unreachable objects are freed.
* Compacting may occur to reduce fragmentation.

### 4. Key Properties

* Optimized for large, simple objects.
* Minimal pointer traversal → GC faster for these objects compared to Old Pointer Space.
* Less frequent allocation than New Space.

Summary:

* **Purpose:** Store long-lived large/simple objects efficiently.
* **GC:** Major GC handles marking, sweeping, and optional compaction.
* **Allocation:** Stable and slower than New Space.
* **Performance:** Optimized for objects with fewer references.

================ 4. Code Space ==============>>>

### 1. What is Code Space?

* Dedicated memory region in V8 heap for **compiled JavaScript code**.
* Includes **bytecode and JIT-compiled machine code**.
* Executable memory (CPU rules require code to be in separate memory region).

### 2. Objects Allocated Here

* Functions after JIT compilation.

* Example:-
function add(a, b) { return a + b; }

Compiled into machine code and stored in Code Space

* Optimized functions hot-paths compiled to TurboFan machine code.

### 3. Garbage Collection

* Managed by **Major GC**.
* Compiled code can be discarded if function is no longer reachable or optimized differently.
* Helps prevent memory leaks in long-running applications.

### 4. Key Properties

* Stores only executable code.
* Separate from data to follow CPU security rules (code execution permissions).
* Optimized for frequent access during function calls.
* Avoids cluttering heap with code objects.

Summary:

* **Purpose:** Store compiled JavaScript code safely and efficiently.
* **GC:** Major GC frees unreachable or replaced code.
* **Allocation:** Executable memory, separate from data.
* **Performance:** Optimized for fast execution of hot functions.

=========== 5. Map Space (Hidden Classes / Object Shapes)=====>>>>>>

**1. What is Map Space?**

* Map Space is a special area in V8 heap.
* Stores hidden classes or object shapes.
* Helps fast lookup for object properties.

**2. Why Hidden Classes / Maps?**

* JS objects are dynamic; properties can change anytime.
* Direct property access can be slow.
* Hidden classes tell V8 object structure and order.

**3. Example:**
let obj = { x: 10, y: 20 };

* V8 creates a Map internally:

  * x → offset 0
  * y → offset 1
* Access obj.x → V8 uses offset 0, very fast.

**4. Object Shape Transition:**
obj.z = 30;

* V8 creates a new hidden class / map.
* Old map → new map chain created.

**5. Benefits of Map Space:**

* Fast property access (inline caching).
* Optimized JIT compilation.
* Reduces runtime lookup cost.

**6. Mental Picture:**

* Map Space = registry office / blueprint storage.
* Stores structure for each object.
* Keeps object memory small & access fast.

Summary:

* Map Space stores hidden classes / object shapes.
* Helps fast property access and JIT optimization.
* Dynamic property changes may create new maps.

================ 6. Large Object Space (LOS) ===========>>>>>

**1. What is Large Object Space (LOS)?**

* LOS is a special area in V8 heap for very large objects.
* Objects too big to fit in the normal semi-space (New Space) are allocated here.

**2. Why LOS exists?**

* Copying very large objects during Minor GC is costly.
* LOS prevents repeated copying and keeps memory management efficient.

**3. What goes into LOS?**

* Very large arrays, buffers, big strings.
* Objects larger than a semi-space block.

**4. Garbage Collection in LOS:**

* Major GC manages LOS.
* Objects here may not be moved frequently due to size.
* Fragmentation can happen because objects are big and scattered.

**5. Allocation Strategy:**

* Objects are directly placed in LOS instead of New Space.
* Reduces copying overhead.
* May use first-fit or best-fit strategy to place objects in gaps.

**6. Mental Picture:**

* Think of LOS as a warehouse for giant items.
* Small items go in drawers (New Space), but giant objects need their own space.
* Cleaning happens less frequently but carefully.

Summary:

* LOS stores very large objects.
* Prevents copying overhead during Minor GC.
* Managed by Major GC.
* Fragmentation possible but efficient for big objects.

========= 7. Shared Space ==================>>>>>

**1. What is Shared Space?**

* Shared Space is a special area in the V8 heap.
* It is designed for objects that are used across multiple isolates (like workers).

**2. Why is it needed?**

* In modern JS, multiple workers or threads may share common data.
* Shared Space allows safe and efficient sharing without duplication.

**3. What kind of objects go into Shared Space?**

* WebAssembly objects.
* Objects shared between multiple V8 isolates.
* Immutable or read-mostly objects that need to be accessed by multiple threads.

**4. Benefits of Shared Space:**

* Avoids multiple copies of the same object across threads.
* Provides consistent data access for multiple workers.
* Reduces memory usage and improves performance.

**5. How is it managed?**

* Managed by V8's garbage collector for shared objects.
* Access synchronization is handled internally to avoid race conditions.
* Mostly used in multi-threaded or worker-based environments.

**6. Mental Picture:**

* Think of Shared Space as a public park.
* Everyone can visit, use, and enjoy it without altering the original objects.
* Efficient for multiple visitors (workers) to access the same resources safely.

Summary:-
* Shared Space stores objects accessed across multiple V8 isolates.
* Reduces duplication and improves efficiency in multi-threaded JS.
* Managed safely by V8 to prevent conflicts.

============ 8. Read-Only Space (Museum) =============>>>>>

**1. What is Read-Only Space?**

* Read-Only Space is a special memory area in the V8 heap.
* Objects placed here cannot be modified.
* Purpose: store immutable objects for safety and performance.

**2. Why Read-Only Space exists?**

* Protects constants and built-in objects from accidental changes.
* Optimizes memory access because objects are guaranteed not to change.
* Helps V8 make assumptions for faster code execution.

**3. What kind of objects go here?**

* Built-in constants (e.g., Math.PI, Number.MAX\_VALUE).
* Interned strings (common strings reused in multiple places).
* Immutable data that should never change in the program.

**4. How is it managed?**

* V8 places an object here when it detects it will not be modified.
* Read-Only memory is marked at OS level to prevent write operations.
* Garbage collection still tracks references but objects themselves are immutable.

**5. When and how it is used?**

* At script start, V8 preloads built-in constants into Read-Only Space.
* During execution, interned strings or immutable literals can be placed here.
* Accessing these objects is fast because memory is fixed and safe.

**6. Mental Picture / Analogy:**

* Think of it as a museum.
* Objects are displayed for use but cannot be changed.
* Visitors (code) can read and use, but cannot write or modify.

**7. Example in JS:**
console.log(Math.PI); // 3.14159... (constant, stored in Read-Only Space)
const str = "hello"; // Interned string may be stored in Read-Only Space

**8. Key Points:**

* Memory cannot be modified (read-only).
* Fast access and safe usage.
* Stores constants, built-in values, and immutable data.
* Managed by V8 automatically.

--------------------------------------------------------------------------------------

============ V8 Object Layout & Hidden Classes (Maps) ===========>>>>>>

**1. Basic Problem**

* JavaScript is dynamic → properties can be added, removed, or changed anytime.

* Example:
let obj = {};
obj.a = 10;
obj.b = 20;
obj.c = "hello";

* If V8 treated every object like a dictionary (property name → value) each access would be slow.

**2. Hidden Classes (Maps)**

* V8 creates a hidden class (also called a Map or shape) for each object to speed things up.
* This is like a blueprint showing which fields exist and in what order.

* Example:
let p = {x: 10, y: 20};

* V8 creates a hidden class:

  * Field #0 → x
  * Field #1 → y
* Object `p`’s data is then stored in a fixed layout in the heap.

**3. Transition Chains**

* Adding new properties changes the hidden class of an object.
* Example:

let p = {};        // Hidden class HC0
p.x = 10;          // Transition to HC1 (x added)
p.y = 20;          // Transition to HC2 (y added)

* V8 maintains transition chains to efficiently manage objects with similar structure.

**4. Inline Properties vs Dictionary Mode**

* Small, predictable objects → properties stored inline.
* Objects with many dynamic changes → shift to dictionary mode (slower, flexible).
* Optimized JIT code prefers inline, predictable layouts.

**5. Object Layout in Heap**

* Simplified memory layout:

Object {
  [Map pointer] --> HiddenClass { x: slot0, y: slot1 }
  slot0 = 10
  slot1 = 20
}

* Header (Map pointer) points to hidden class.
* Properties array stores inline fields.
* Elements array stores indexed array data (if any).

**6. SMI vs HeapNumber**

* Small Integer (SMI): 31/32-bit integers stored directly (fast).
* HeapNumber: floats or big numbers stored as separate heap objects (slower).

* Example:
let a = 42;      // SMI
let b = 3.1415;  // HeapNumber

**7. Pointer Compression**

* On 64-bit machines, pointers are big.
* V8 compresses pointers → stores as 32-bit + base offset.
* Reduces heap memory footprint, important for large apps.

**Mental Picture**

* Each object = a file.
* Cover page = hidden class/map (shows structure).
* Small numbers = written directly (SMI).
* Big numbers = separate diary (HeapNumber).
* Everything tightly packed with pointer compression.

**Summary**

* V8 uses hidden classes (maps) to speed object access.
* Properties: inline or dictionary mode.
* Numbers: SMI (fast) vs HeapNumber (slow).
* Pointer compression saves memory.

================= V8 GC Optimizations =============================>>>>>>>s

Main Problem:

-- GC (Garbage Collector) must clean memory, otherwise heap overfills.
-- But cleaning can pause the main JS thread → app may freeze or slow down.
-- V8 solves this using multiple optimizations to keep pauses minimal and performance smooth.

1. Generational GC

-- Heap is split into two generations:
-- Young Generation (New Space): Short-lived objects (temporary, quick objects).
-- Old Generation (Old Space): Long-lived objects (configs, app-level caches).
-- Observation: Most objects die young → minor GC (new-space) runs fast and frequently.
-- Major GC (old-space) runs rarely because objects here live longer.

2. Incremental Marking

-- Traditional mark-sweep GC marked everything at once → causes big pauses.
-- V8 breaks the marking into small steps:
-- Mark some objects → run JS → mark more → repeat.
-- Benefit: pauses are small and mostly unnoticeable.

3. Concurrent Marking

-- Uses background threads.
-- While main thread runs JS, GC background thread marks objects in parallel.
-- User experiences no pause; app continues running smoothly.

4. Compaction Optimization

-- Old-space fragmentation happens → free memory scattered.
-- V8 moves surviving objects to make contiguous memory blocks.
-- Compaction is costly, so V8 does incremental compaction or during idle-time.
-- Result: fast allocation and smooth performance.

5. Idle-Time GC

-- GC runs when CPU is free / app is idle.
-- Example: Browser not scrolling → V8 cleans memory quietly in background.
-- Benefit: memory cleaned without affecting user experience.

6. Parallel Scavenge

-- Minor GC (new-space cleanup) is multi-threaded.
-- Multiple cores copy & clean memory at the same time → very fast.
-- Perfect for short-lived objects.

7. Write Barriers & Remembered Sets

-- Problem: New-space objects may reference Old-space objects or vice-versa.
-- GC needs to track these references for correctness.
-- Write Barrier: mechanism that ensures GC notices these references.
-- Critical for generational GC correctness.